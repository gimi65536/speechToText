<!DOCTYPE html>

<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>speech to text</title>
  <style type='text/css'>
    ul { list-style: none; }
    #recordingslist audio { display: block; margin-bottom: 10px; }
  </style>
</head>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="{{
  url_for('static', filename='jquery-3.3.1.min.js') }}">\x3C/script>')</script>

<body>

  <h1>Speech to Text (Using Recorder.js)</h1>

  <p>Make sure you are using a recent version of Google Chrome.</p>
  <p>Also before you enable microphone input either plug in headphones or turn the volume down if you want to avoid ear splitting feedback!</p>

  <button id="record" onclick="startRecording(this);">record</button>
  <button id="stop" onclick="stopRecording(this);" disabled>stop</button>

  <h2>Recordings</h2>
  <ul id="recordingslist"></ul>

  <h2>Results</h2>
  <pre id="results"></pre>
  
  <h2>Recommendation</h2>
  <textarea id="recommendation" style="width:800px;height:100px;"></textarea>

  <h2>Log</h2>
  <pre id="log"></pre>

  <script>
  function __log(e, data) {
    log.innerHTML += "\n" + e + " " + (data || '');
  }

  var audio_context;
  var recorder;
  var fnames = [];

  function startUserMedia(stream) {
    var input = audio_context.createMediaStreamSource(stream);
    __log('Media stream created.');

    // Uncomment if you want the audio to feedback directly
    //input.connect(audio_context.destination);
    //__log('Input connected to audio context destination.');
    
    recorder = new Recorder(input);
    __log('Recorder initialised.');
  }

  function startRecording(button) {
    recorder && recorder.record();
    button.disabled = true;
    button.nextElementSibling.disabled = false;
    __log('Recording...');
  }

  function stopRecording(button) {
    recorder && recorder.stop();
    button.disabled = true;
    button.previousElementSibling.disabled = false;
    __log('Stopped recording.');
    
    // upload to server
    uploadToServer();
    
    recorder.clear();
  }

  function uploadToServer() {
    recorder && recorder.exportWAV(function(blob) {
      var last_fname = (new Date().toISOString() + '.wav').replace(/:/g, "_");
      fnames.push(last_fname);

      var reader = new FileReader();
      // this function is triggered once a call to readAsDataURL returns
      reader.onload = function(event){
          var fd = new FormData();
          fd.append('fname', last_fname);
          fd.append('data', event.target.result);
          $.ajax({
              type: 'POST',
              url: '/upload',
              data: fd,
              processData: false,
              contentType: false
          }).done(function(data) {
              __log('Upload to server successfully.');
          }).fail(function(jqXHR, textStatus, error) {
              __log('Upload to server failed')
          });

      };      
      // trigger the read from the reader...
      reader.readAsDataURL(blob);

      createAudioHTML(blob);
    });
  }

  function createAudioHTML(blob) {
    // create audio and buttons
    var url = URL.createObjectURL(blob);
    var li = document.createElement('li');
    var au = document.createElement('audio');
    var hf = document.createElement('a');

    au.controls = true;
    au.src = url;
    hf.href = url;
    hf.download = fnames[fnames.length - 1];
    hf.innerHTML = hf.download;
    li.appendChild(au);
    li.appendChild(hf);
    
    var recBtn = document.createElement('button');
    var t = document.createTextNode('recognize');
    recBtn.appendChild(t);
    recBtn.onclick = function(){
      __log("Recognizing...")
      document.getElementById("results").innerHTML = "Recognizing..."
      var fd = new FormData();
      fd.append('fname', hf.download);
      $.ajax({
          type: 'POST',
          url: '/recog',
          data: fd,
          processData: false,
          contentType: false
      }).done(function(data) {
          results_text = document.getElementById("results")
          recommendation_text = document.getElementById("recommendation")
          if (data["no_exception"]) {
            if (!data["exceed_quota"]) {
              results_text.innerHTML = "google: " + data["results"][0] + '\n' + "ibm: " + data["results"][1] + '\n' + "wit: " + data["results"][2] + '\n' + "hundify: " + data["results"][3]
            }
            else {
              results_text.innerHTML = "google: " + data["results"][0] + '\n' + "ibm: " + data["results"][1] + '\n' + "wit: " + data["results"][2] + '\n' + "houndify quota exceeded!"
            }
            results_text.innerHTML += '<hr>'
            results_text.innerHTML += '\n' + data["alignment"]
            recommendation_text.value = recommendation_text.value + data["recommendation"] + '\n'
          }
          else {
            results_text.innerHTML = "Your voice is not clear enough, please try again!"
          }
          
          __log("Complete!")
      }).fail(function(jqXHR, textStatus, error) {
          __log("Failed!")
      });
    }
    li.appendChild(recBtn);

    recordingslist.appendChild(li);
  }

  window.onload = function init() {
    try {
      // webkit shim
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia;
      window.URL = window.URL || window.webkitURL;
      
      audio_context = new AudioContext;
      __log('Audio context set up.');
      __log('navigator.getUserMedia ' + (navigator.getUserMedia ? 'available.' : 'not present!'));
    } catch (e) {
      alert('No web audio support in this browser!');
    }
    
    navigator.getUserMedia({audio: true}, startUserMedia, function(e) {
      __log('No live audio input: ' + e);
    });
  };

  window.onbeforeunload = function() {
    var fd = new FormData();
    for (var i = fnames.length - 1; i >= 0; i--) {
      fd.append('fnames', fnames[i]);
    }
    
    $.ajax({
        type: 'POST',
        url: '/deleteAudios',
        data: fd,
        processData: false,
        contentType: false
    }).done(function(data) {
        
    }).fail(function(jqXHR, textStatus, error) {
        
    });
  }
  </script>

  <script src="{{ url_for('static', filename="recorder.js") }}"></script>
</body>
</html>
